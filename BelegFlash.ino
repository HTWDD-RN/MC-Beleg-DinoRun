#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <SPI.h>
#include <EEPROM.h>
//#include <SdFat.h>

// TODO: 
// - bessere Sprungberechnung mit Parabel (Gravity und Sprungzeit)
// - Schauen wie lange ein Frame zum Zeichnen braucht und die delay entsprechend anpassen (Delta Time) -> Abziehen der Zeit zum Zeichnen/Logik OK
// - mehrere verschiedene Kakteen als neue Bilder, vielleicht auch mehrere Kakteen auf einmal / zusätzlich Vogel -> als Array?
// - Geschwindigkeit langsam erhöhen bei Score Meilensteinen (alle 100)
// - Grafik für Boden -> Pixel als Steine
// - vielleicht auch noch zweite Taste zum Ducken hinzufügen, wenn Vogel kommt OK
// - Titelbildschirm
// - GameOver Bildschirm OK, aber vielleicht erst nach Tastendruck fortsetzen?
// - Sound über Beeper
// - Landscape Orientation für das Display? OK
// - HighScore auf SDCard speichern? OK aber auf EEPROM, vielleicht später mal auf SDCard
// - wir haben Stand jetzt nur noch ~3.5K Flash Speicher!! -> nutzen jetzt Flash OK
// - -> Bilder müssen deshalb von SDCard geladen werden -> wie bekommt man das Blinken beim Zugriff auf SDCard weg??

// Pinbelegung für das TFT-Display
#define TFT_CS     10
#define TFT_DC     9
#define TFT_RST    8
#define SD_CS      4   

#define JMP_BUTTON_PIN 2
#define DUCK_BUTTON_PIN 3

// VCC: 5V, LED: 3,3V!!
// SDA: 11, SCK: 13 (für TFT/SD)

// SD MISO : 12
// SD MOSI: SDA (11)
// SD CLK: SCK (13)

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

// https://javl.github.io/image2cpp/
// 'bird', 42x26px
const unsigned char epd_bitmap_bird [] PROGMEM = {
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xc0, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xf0, 0x00, 0x00, 0x00, 
	0x0f, 0xc3, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xc3, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xf3, 0xff, 0xc0, 
	0x00, 0x00, 0x3f, 0xf3, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xf3, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xf3, 
	0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00
};
// 'bird2', 42x30px
const unsigned char epd_bitmap_bird2 [] PROGMEM = {
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xc0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0x00, 0x00, 0x00
};
// 'cactus', 23x48px
const unsigned char epd_bitmap_cactus [] PROGMEM = {
	0x00, 0x7c, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 
	0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 
	0x1c, 0x00, 0xfe, 0x3e, 0x70, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 
	0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 
	0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xff, 0xff, 
	0xfc, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xf0, 0x3f, 0xff, 0xe0, 0x1f, 0xfe, 0x00, 0x00, 0xfe, 0x00, 
	0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 
	0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 
	0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x20, 0x0b, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00
};
// 'cactus2', 49x48px
const unsigned char epd_bitmap_cactus2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x01, 0xc0, 
	0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 
	0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x1c, 0x3f, 0x80, 
	0x00, 0x03, 0xe1, 0x00, 0x3e, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x80, 0x00, 0x03, 
	0xe3, 0x80, 0x3e, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x80, 
	0x3e, 0x3f, 0x87, 0x00, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 
	0x8f, 0x80, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 
	0x63, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xff, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xff, 
	0x00, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xfe, 0x08, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xe0, 0x1c, 0x3f, 
	0xff, 0x8f, 0x80, 0xf3, 0xe0, 0x1c, 0x3f, 0xff, 0x8f, 0x80, 0xf3, 0xe0, 0x1c, 0x1f, 0xff, 0x8f, 
	0x80, 0xf3, 0xe0, 0x1c, 0x0f, 0xff, 0x8f, 0x80, 0xf3, 0xe1, 0x1c, 0x47, 0xff, 0x8f, 0x80, 0xf3, 
	0xe3, 0x9c, 0xe0, 0x3f, 0x8f, 0x80, 0xf3, 0xe3, 0x9c, 0xe0, 0x3f, 0x8f, 0x00, 0xf3, 0xe3, 0x9c, 
	0xe0, 0x3f, 0xfe, 0x00, 0xf3, 0xe3, 0x9c, 0xe0, 0x3f, 0xfc, 0x00, 0xff, 0xe3, 0x9c, 0xe0, 0x3f, 
	0xf8, 0x00, 0x7f, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 0x3f, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 
	0x1f, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 0x03, 0xe1, 
	0xff, 0xc0, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0xff, 0x80, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x7c, 0x00, 
	0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 
	0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 
	0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 
	0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x88, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 
	0x80, 0x00, 0x03, 0xe0, 0x1c, 0x02, 0xff, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x40, 0x00
};
// 'cloud', 46x13px
const unsigned char epd_bitmap_cloud [] PROGMEM = {
	0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xce, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0xe0, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x3f, 0x00, 0x00, 0x03, 0xc0, 0x02, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0xe0, 
	0x03, 0xfc, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x38, 0x04, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x6c, 0x40, 0x00, 0x00, 0x00, 0x04, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xfc
};
// 'dead', 20x21px
const unsigned char epd_bitmap_dead [] PROGMEM = {
	0x00, 0x1f, 0xe0, 0x00, 0x33, 0xf0, 0x00, 0x37, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 
	0x3f, 0xf0, 0x00, 0x3f, 0xc0, 0x80, 0x7c, 0x00, 0x80, 0xfc, 0x00, 0xc3, 0xff, 0x00, 0xe7, 0xfd, 
	0x00, 0xff, 0xfc, 0x00, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 
	0x0f, 0xe0, 0x00, 0x07, 0x60, 0x00, 0x06, 0x20, 0x00, 0x04, 0x20, 0x00, 0x06, 0x30, 0x00
};
// 'dino2', 20x21px
const unsigned char epd_bitmap_dino2 [] PROGMEM = {
	0x00, 0x1f, 0xe0, 0x00, 0x37, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 
	0x3e, 0x00, 0x00, 0x3f, 0xc0, 0x80, 0x7c, 0x00, 0x80, 0xfc, 0x00, 0xc3, 0xff, 0x00, 0xe7, 0xfd, 
	0x00, 0xff, 0xfc, 0x00, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 
	0x0f, 0xe0, 0x00, 0x06, 0x60, 0x00, 0x03, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x30, 0x00
};
// 'dino', 20x21px
const unsigned char epd_bitmap_dino [] PROGMEM = {
	0x00, 0x1f, 0xe0, 0x00, 0x37, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 
	0x3e, 0x00, 0x00, 0x3f, 0xc0, 0x80, 0x7c, 0x00, 0x80, 0xfc, 0x00, 0xc3, 0xff, 0x00, 0xe7, 0xfd, 
	0x00, 0xff, 0xfc, 0x00, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 
	0x0f, 0xe0, 0x00, 0x07, 0x38, 0x00, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00, 0x00
};
// 'duck', 28x13px
const unsigned char epd_bitmap_duck [] PROGMEM = {
	0xc0, 0x00, 0x1f, 0xe0, 0xf0, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0xf7, 0xf0, 0x3f, 0xff, 0xff, 0xf0, 
	0x1f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xfe, 0x00, 0x03, 0xff, 0x9f, 0xc0, 
	0x01, 0xf9, 0x00, 0x00, 0x03, 0x9d, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00
};
// 'duck2', 28x13px
const unsigned char epd_bitmap_duck2 [] PROGMEM = {
	0xc0, 0x00, 0x1f, 0xe0, 0xf0, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0xf7, 0xf0, 0x3f, 0xff, 0xff, 0xf0, 
	0x1f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf0, 0x07, 0xff, 0xfe, 0x00, 0x03, 0xff, 0x9f, 0xc0, 
	0x01, 0xf9, 0x00, 0x00, 0x02, 0x71, 0x80, 0x00, 0x03, 0x60, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x60, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1616)
const int epd_bitmap_allArray_LEN = 10;
const unsigned char* epd_bitmap_allArray[10] = {
	epd_bitmap_bird,
	epd_bitmap_bird2,
	epd_bitmap_cactus,
	epd_bitmap_cactus2,
	epd_bitmap_cloud,
	epd_bitmap_dead,
	epd_bitmap_dino2,
	epd_bitmap_dino,
	epd_bitmap_duck,
	epd_bitmap_duck2
};

#define DinoX 5
#define DinoYStart 90
int DinoY = DinoYStart;
#define DinoWidth 20
#define DinoHeight 21
#define DinoDuckWidth 28
#define DinoDuckHeight 13
int DinoFrame = 0; // AnimationsFrame
#define DinoDuckYOffset 8; // Offset für geduckten Dino
bool wasDucking = false;

int CloudX = tft.width() + random(-100, 70); // random Offset
#define CloudY 40
#define CloudWidth 46
#define CloudHeight 13

int CactusX = tft.width() + random(20, 100); // random Offset
#define CactusY 80
#define CactusWidth 23
#define CactusHeight 48

#define HLLineY 111

#define ScoreX 5
#define ScoreY 5

// Delta X (px pro Frame)
int CloudDX = 2;
int CactusDX = 4;  

int targetFrameDelay = 90; // Ziel Frametime in ms, wird reduziert durch Zeichenaufwand

#define EEPROMHighscore 0 // Highscore permant in EEPROM speichern
int highscore = 0;
int score = 0;
// Score ist auch Framecounter
int lastScore = 0;
int fps = 0;
unsigned long lastFPSUpdate = 0;

const int jumpHeights[] = {
  -13, -10, -7, -5, -4, -3, -2, -1,
   0,
   1, 2, 3, 4, 5, 7, 10, 13
};
const int jumpLength = sizeof(jumpHeights) / sizeof(jumpHeights[0]); // Länge = ArrayLänge in Byte / Größe ArrayElement
bool jump = false;
int jumpProgress = 0;

bool duck = false;

int dead = 0;

/*
//Sd2Card card;
//SdVolume volume;
//SdFile root;
SdFat SD;
File myFile;
*/

void jumpButtonFunc(){
  jump = true;
}

/*
void initSD(){
  Serial.print("Init SD card...");
  tft.setCursor(40, 50);
  tft.print("SD init...");

  if (!SD.begin(SD_CS)){
    Serial.println("FAIL!");
    tft.print("FAIL!");
    return;
  }
  Serial.println("OK!");
  tft.print("OK!");


  if (!card.init(SPI_HALF_SPEED, SD_CS)) {
    Serial.println("FAIL!");
    tft.print("FAIL!");
    return;
  }
  Serial.println("OK!");
  tft.print("OK!");

  Serial.print("Card type: ");
  switch (card.type()) {
    case SD_CARD_TYPE_SD1:  Serial.println("SD1");  break;
    case SD_CARD_TYPE_SD2:  Serial.println("SD2");  break;
    case SD_CARD_TYPE_SDHC: Serial.println("SDHC"); break;
    default:                Serial.println("Unknown");
  }

  
  if (!volume.init(card)) {
    Serial.println("Volume init fail");
    tft.setCursor(40, 70);
    tft.print("No FAT?");
    return;
  }

   uint32_t volumeSize = volume.clusterCount() * volume.blocksPerCluster() / 2; // in KB
  Serial.print("Volume size (MB): ");
  Serial.println(volumeSize / 1024.0, 2);

  tft.setCursor(40, 70);
  tft.print("Size: ");
  tft.print(volumeSize / 1024.0, 2);
  tft.print("MB");
  

  myFile = SD.open("/test.txt", FILE_WRITE);
  // if the file opened okay, write to it:
  if (myFile) {
    Serial.print("Writing to test.txt...");
    myFile.println("testing 1, 2, 3.");
    // close the file:
    myFile.close();
  }
  else{
    Serial.println(String("Return Code: ") + myFile);
  }
}
*/

void setup() {
  pinMode(JMP_BUTTON_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(JMP_BUTTON_PIN), jumpButtonFunc, FALLING);

  pinMode(DUCK_BUTTON_PIN, INPUT_PULLUP);

  Serial.begin(115200);

  // Initialisiere das TFT-Display
  tft.initR(INITR_BLACKTAB);
  
  tft.setRotation(1);
  tft.fillScreen(ST7735_WHITE);
  tft.setTextColor(ST7735_BLACK);

  //initSD();
  Serial.print("");
  delay(1000);

  reset();
}

void reset(){
  tft.fillScreen(ST7735_WHITE);

  tft.setCursor(55, 5);
  tft.print("HI:");
  
  #if EEPROMHighscore == 1
  EEPROM.get(0, highscore);
  #endif
  tft.print(highscore);
  
  score = 0;
  lastScore = 0;
  fps = 0;
  lastFPSUpdate = 0;

  jump = false;
  jumpProgress = 0;

  duck = false;
  wasDucking = false;

  dead = 0;

  CloudX = tft.width() + random(-100, 70);
  CactusX = tft.width() + random(20, 100);
  DinoY = DinoYStart;
}

// https://kishimotostudios.com/articles/aabb_collision/
bool checkAABBCollision(int AX, int AY, int AWidth, int AHeight, int BX, int BY, int BWidth, int BHeight){
  int8_t padding = 4;

  int ALeft = AX + padding;
  int ARight = AX + AWidth - padding;
  int ATop = AY + padding;
  int ABottom = AY + AHeight - padding;

  int BLeft = BX;
  int BRight = BX + BWidth;
  int BTop = BY;
  int BBottom = BY + BHeight;

  bool AisToTheRightOfB = ALeft > BRight;
  bool AisToTheLeftOfB = ARight < BLeft;
  bool AisAboveB = ABottom < BTop;
  bool AisBelowB = ATop > BBottom;

  return !(AisToTheRightOfB || AisToTheLeftOfB || AisAboveB || AisBelowB);
}

int drawFrame(){
  // Ducken -> Offset beim Umschalten setzen/entfernen
  bool isPressed = digitalRead(DUCK_BUTTON_PIN) == LOW;
  if (isPressed == true && wasDucking == false && jump == false) { // ducken nicht erlaubt beim Springen
    // starten des ducken
    tft.fillRect(DinoX, DinoY, DinoWidth, DinoHeight, ST7735_WHITE); // Normaler Dino
    DinoY += DinoDuckYOffset;
    wasDucking = true;
    duck = true;

  } else if (isPressed == false && wasDucking == true) {
    // aufhören zu ducken
    tft.fillRect(DinoX, DinoY, DinoDuckWidth, DinoDuckHeight, ST7735_WHITE); // Duck Dino
    DinoY -= DinoDuckYOffset;
    wasDucking = false;
    duck = false;
  }

  // Löschen
  tft.fillRect(CloudX, CloudY, CloudWidth, CloudHeight, ST7735_WHITE); // Wolke
  tft.fillRect(CactusX, CactusY, CactusWidth, CactusHeight, ST7735_WHITE); // Kaktus
  if (duck == true){
    tft.fillRect(DinoX, DinoY, DinoDuckWidth, DinoDuckHeight, ST7735_WHITE); // Duck Dino
    jump = false;
  }
  else {
    tft.fillRect(DinoX, DinoY, DinoWidth, DinoHeight, ST7735_WHITE); // Normaler Dino
  }

  tft.fillRect(ScoreX, ScoreY, 30, 10, ST7735_WHITE); // Score

  // Neue Wolkenposition
  CloudX -= CloudDX;
  if (CloudX <= -CloudWidth) {
    CloudX = tft.width() + random(10,70);
  }

  // Neue Kaktusposition
  CactusX -= CactusDX;
  if (CactusX <= -CactusWidth) {
    CactusX = tft.width() + random(20,100);
  }

  // Todo: Sprungpos. dynamisch berechnen
  if (jump == true && duck == false) {
    DinoY += jumpHeights[jumpProgress];
    jumpProgress++;

    if (jumpProgress >= jumpLength) {
      jump = false;
      jumpProgress = 0;
    }
  }

  score++;
  tft.setCursor(ScoreX, ScoreY);
  tft.print(score);

  // Kollision?
  if (duck == true){
    if (checkAABBCollision(DinoX, DinoY, DinoDuckWidth, DinoDuckHeight, CactusX, CactusY, CactusWidth, CactusHeight)){
      Serial.println("Collison?");
      dead = 1;
    }
  }
  else{
    if (checkAABBCollision(DinoX, DinoY, DinoWidth, DinoHeight, CactusX, CactusY, CactusWidth, CactusHeight)){
      Serial.println("Collison?");
      dead = 1;
    }
  }
  
  tft.drawFastHLine(0, HLLineY, tft.width(), ST7735_BLACK); // horizontale Linie
  
  tft.drawBitmap(CloudX, CloudY, epd_bitmap_cloud, CloudWidth, CloudHeight, tft.color565(150, 150, 150));
  tft.drawBitmap(CactusX, CactusY, epd_bitmap_cactus, CactusWidth, CactusHeight, tft.color565(50, 50, 50));
  //tft.drawRect(CactusX, CactusY, CactusWidth, CactusHeight, ST77XX_RED); // Hitbox

  // Dino animieren
  if (dead != 1){
    if (DinoFrame == 0){
      DinoFrame = 1;
      if (duck == true){
        //tft.drawRect(DinoX + 4, DinoY + 4, DinoDuckWidth - 2 * 4, DinoDuckHeight - 2 * 4, ST77XX_BLUE); // Hitbox
        tft.drawBitmap(DinoX, DinoY, epd_bitmap_duck, DinoDuckWidth, DinoDuckHeight, tft.color565(50, 50, 50));
      }
      else {
        //tft.drawRect(DinoX + 4, DinoY + 4, DinoWidth - 2 * 4, DinoHeight - 2 * 4, ST77XX_BLUE); // Hitbox
        tft.drawBitmap(DinoX, DinoY, epd_bitmap_dino, DinoWidth, DinoHeight, tft.color565(50, 50, 50));
      }
    }
    else if (DinoFrame == 1){
      DinoFrame = 0;
      if (duck == true){
        //tft.drawRect(DinoX + 4, DinoY + 4, DinoDuckWidth - 2 * 4, DinoDuckHeight - 2 * 4, ST77XX_BLUE); // Hitbox
        tft.drawBitmap(DinoX, DinoY, epd_bitmap_duck2, DinoDuckWidth, DinoDuckHeight, tft.color565(50, 50, 50));
      }
      else{
        //tft.drawRect(DinoX + 4, DinoY + 4, DinoWidth - 2 * 4, DinoHeight - 2 * 4, ST77XX_BLUE); // Hitbox
        tft.drawBitmap(DinoX, DinoY, epd_bitmap_dino2, DinoWidth, DinoHeight, tft.color565(50, 50, 50));
      }
    }
    return 0;
  }
  else { // tot
    if (duck == true){
      DinoY -= DinoDuckYOffset;
    }
    //tft.drawRect(DinoX + 4, DinoY + 4, DinoWidth - 2 * 4, DinoHeight - 2 * 4, ST77XX_BLUE);
    tft.drawBitmap(DinoX, DinoY, epd_bitmap_dead, DinoWidth, DinoHeight, ST77XX_RED);
    return 1;
  }
}

void loop() {
  unsigned long now = millis();
  if (now - lastFPSUpdate >= 1000) { // FPS jede Sek anzeigen
    fps = score - lastScore;
    lastScore = score;
    lastFPSUpdate = now;

    tft.fillRect(tft.width() - 40, 5, 40, 10, ST7735_WHITE);
    tft.setCursor(tft.width() - 40, 5);
    tft.print(String("FPS:") + fps);
    Serial.println(String("FPS: ") + fps);
  }

    unsigned long frameStart = millis();
    
    int status = drawFrame();
    if (status == 1){ // tot -> GameOver
      tft.setTextSize(2);
      tft.setTextColor(ST7735_RED);
      tft.fillRect(23, 47, 110, 20, ST7735_WHITE);
      tft.drawRect(23, 47, 110, 20, ST7735_RED);
      tft.setCursor(25, 50);
      tft.print("GAME OVER");
      tft.setTextColor(ST7735_BLACK);
      tft.setTextSize(1);

      #if EEPROMHighscore == 1
      // neuer Highscore?
      Serial.println(String("EEPROM val: ") + EEPROM.get(0, highscore));
      EEPROM.get(0, highscore);
      if (score > highscore){
        EEPROM.put(0, score);
      }
      #else 
      if (score > highscore){
        highscore = score;
      }
      #endif

      delay(2000);
      reset();
    }
    else if (status == 0){ // geht weiter
      // DeltaTime
      unsigned long frameEnd = millis();
      unsigned long frameTime = frameEnd - frameStart;
      //Serial.println(String("FrameTime: ") + round(frameTime));
      if (targetFrameDelay - (int)frameTime <= 0){ // FPS drop! -> mehr Zeit zum Zeichnen benötigt als TargetFrameTime
        delay(0);
      }
      else{
        delay(targetFrameDelay - round(frameTime));
      }
    }
}


