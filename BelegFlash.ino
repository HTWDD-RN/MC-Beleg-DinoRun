//#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
//#include <Adafruit_ImageReader.h>
#include <SPI.h>

// TODO: 
// - bessere Sprungberechnung mit Parabel (Gravity und Sprungzeit)
// - Schauen wie lange ein Frame zum Zeichnen braucht und die delay entsprechend anpassen (Delta Time) -> Abziehen der Zeit zum Zeichnen/Logik
// - mehrere verschiedene Kakteen als neue Bilder, vielleicht auch mehere Kakteen auf einmal
// - Grafik für Boden -> Pixel als Steine
// - vielleicht auch noch zweite Taste zum Ducken hinzufügen, wenn Vogel kommt
// - Titelbildschirm/GameOver Bildschirm
// - Sound über Beeper
// - Landscape Orientation für das Display?
// - HighScore auf SDCard speichern?
// - wir haben Stand jetzt nur noch ~3.5K Flash Speicher!!
// - -> Bilder müssen deshalb von SDCard geladen werden -> wie bekommt man das Blinken beim Zugriff auf SDCard weg??

// Pinbelegung für das TFT-Display
#define TFT_CS     10
#define TFT_DC     9
#define TFT_RST    8
#define SD_CS      4   

#define BUTTON_PIN 2

// VCC: 5V, LED: 3,3V!!
// SDA: 11, SCK: 13 (für TFT/SD)

// SD MISO : 12
// SD MOSI: SDA (11)
// SD CLK: SCK (13)

Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

// https://javl.github.io/image2cpp/

// 'bird', 42x26px
const unsigned char epd_bitmap_bird [] PROGMEM = {
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xc0, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xf0, 0x00, 0x00, 0x00, 
	0x0f, 0xc3, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xc3, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xf3, 0xff, 0xc0, 
	0x00, 0x00, 0x3f, 0xf3, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xf3, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xf3, 
	0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 
	0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00
};
// 'bird2', 42x30px
const unsigned char epd_bitmap_bird2 [] PROGMEM = {
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0xc0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0x00, 0x00, 0x00
};
// 'cactus', 23x48px
const unsigned char epd_bitmap_cactus [] PROGMEM = {
	0x00, 0x7c, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 
	0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 
	0x1c, 0x00, 0xfe, 0x3e, 0x70, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 
	0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 
	0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xf8, 0xfe, 0x3e, 0xff, 0xff, 
	0xfc, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xf0, 0x3f, 0xff, 0xe0, 0x1f, 0xfe, 0x00, 0x00, 0xfe, 0x00, 
	0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 
	0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 
	0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x20, 0x0b, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00
};
// 'cactus2', 49x48px
const unsigned char epd_bitmap_cactus2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x01, 0xc0, 
	0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 
	0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x00, 0x1c, 0x3f, 0x80, 
	0x00, 0x03, 0xe1, 0x00, 0x3e, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x80, 0x00, 0x03, 
	0xe3, 0x80, 0x3e, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x80, 
	0x3e, 0x3f, 0x87, 0x00, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 
	0x8f, 0x80, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0x03, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 
	0x63, 0xe3, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xff, 0x80, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xff, 
	0x00, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xfe, 0x08, 0x3e, 0x3f, 0x8f, 0x80, 0xf3, 0xe0, 0x1c, 0x3f, 
	0xff, 0x8f, 0x80, 0xf3, 0xe0, 0x1c, 0x3f, 0xff, 0x8f, 0x80, 0xf3, 0xe0, 0x1c, 0x1f, 0xff, 0x8f, 
	0x80, 0xf3, 0xe0, 0x1c, 0x0f, 0xff, 0x8f, 0x80, 0xf3, 0xe1, 0x1c, 0x47, 0xff, 0x8f, 0x80, 0xf3, 
	0xe3, 0x9c, 0xe0, 0x3f, 0x8f, 0x80, 0xf3, 0xe3, 0x9c, 0xe0, 0x3f, 0x8f, 0x00, 0xf3, 0xe3, 0x9c, 
	0xe0, 0x3f, 0xfe, 0x00, 0xf3, 0xe3, 0x9c, 0xe0, 0x3f, 0xfc, 0x00, 0xff, 0xe3, 0x9c, 0xe0, 0x3f, 
	0xf8, 0x00, 0x7f, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 0x3f, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 
	0x1f, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 0x03, 0xe3, 0x9c, 0xe0, 0x3f, 0x80, 0x00, 0x03, 0xe1, 
	0xff, 0xc0, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0xff, 0x80, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x7c, 0x00, 
	0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 
	0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 
	0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 
	0x00, 0x3f, 0x80, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 0x88, 0x00, 0x03, 0xe0, 0x1c, 0x00, 0x3f, 
	0x80, 0x00, 0x03, 0xe0, 0x1c, 0x02, 0xff, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x40, 0x00
};
// 'cloud', 46x13px
const unsigned char epd_bitmap_cloud [] PROGMEM = {
	0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xce, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0xe0, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x3f, 0x00, 0x00, 0x03, 0xc0, 0x02, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0xe0, 
	0x03, 0xfc, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x38, 0x04, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x6c, 0x40, 0x00, 0x00, 0x00, 0x04, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xfc
};
// 'deadhf', 20x21px
const unsigned char epd_bitmap_deadhf [] PROGMEM = {
	0x00, 0x1f, 0xe0, 0x00, 0x33, 0xf0, 0x00, 0x37, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 
	0x3f, 0xf0, 0x00, 0x3f, 0xc0, 0x80, 0x7c, 0x00, 0x80, 0xfc, 0x00, 0xc3, 0xff, 0x00, 0xe7, 0xfd, 
	0x00, 0xff, 0xfc, 0x00, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 
	0x0f, 0xe0, 0x00, 0x07, 0x60, 0x00, 0x06, 0x20, 0x00, 0x04, 0x20, 0x00, 0x06, 0x30, 0x00
};
// 'dino2hf', 20x21px
const unsigned char epd_bitmap_dino2hf [] PROGMEM = {
	0x00, 0x1f, 0xe0, 0x00, 0x37, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 
	0x3e, 0x00, 0x00, 0x3f, 0xc0, 0x80, 0x7c, 0x00, 0x80, 0xfc, 0x00, 0xc3, 0xff, 0x00, 0xe7, 0xfd, 
	0x00, 0xff, 0xfc, 0x00, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 
	0x0f, 0xe0, 0x00, 0x06, 0x60, 0x00, 0x03, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x30, 0x00
};
// 'dinohf', 20x21px
const unsigned char epd_bitmap_dinohf [] PROGMEM = {
	0x00, 0x1f, 0xe0, 0x00, 0x37, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 0x3f, 0xf0, 0x00, 
	0x3e, 0x00, 0x00, 0x3f, 0xc0, 0x80, 0x7c, 0x00, 0x80, 0xfc, 0x00, 0xc3, 0xff, 0x00, 0xe7, 0xfd, 
	0x00, 0xff, 0xfc, 0x00, 0xff, 0xfc, 0x00, 0x7f, 0xfc, 0x00, 0x3f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 
	0x0f, 0xe0, 0x00, 0x07, 0x38, 0x00, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00, 0x00
};
// 'duck', 55x25px
const unsigned char epd_bitmap_duck [] PROGMEM = {
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0xfc, 0x03, 
	0xff, 0xfe, 0x07, 0xff, 0xf8, 0xfc, 0x03, 0xff, 0xfe, 0x1f, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xf8, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x87, 0xff, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0x87, 0xff, 0xe0, 
	0x00, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x1f, 
	0x87, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x87, 0xc7, 0x80, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x07, 
	0x80, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'duck2', 55x25px
const unsigned char epd_bitmap_duck2 [] PROGMEM = {
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf8, 0xfc, 0x03, 
	0xff, 0xfe, 0x07, 0xff, 0xf8, 0xfc, 0x03, 0xff, 0xfe, 0x1f, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xf8, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x87, 0xff, 0xe0, 0x00, 0x3f, 0xff, 0xff, 0x87, 0xff, 0xe0, 
	0x00, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 
	0x7e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0x7e, 0x07, 0x80, 0x00, 0x00, 0x00, 0x1e, 0x78, 0x07, 
	0x80, 0x00, 0x00, 0x00, 0x1e, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1616)
const int epd_bitmap_allArray_LEN = 10;
const unsigned char* epd_bitmap_allArray[10] = {
	epd_bitmap_bird,
	epd_bitmap_bird2,
	epd_bitmap_cactus,
	epd_bitmap_cactus2,
	epd_bitmap_cloud,
	epd_bitmap_deadhf,
	epd_bitmap_dino2hf,
	epd_bitmap_dinohf,
	epd_bitmap_duck,
	epd_bitmap_duck2
};



#define DinoX 5
#define DinoYStart 90
int DinoY = DinoYStart;
int32_t DinoWidth = 20; int32_t DinoHeight = 21;
int DinoFrame = 0;

int CloudX = tft.width() + random(-100, 70); // random Offset
#define CloudY 40
int32_t CloudWidth = 46; int32_t CloudHeight = 13;

int CactusX = tft.width() + random(20, 100); // random Offset
#define CactusY 80
int32_t CactusWidth = 23; int32_t CactusHeight = 48;

#define HLLineY 110

#define ScoreX 5
#define ScoreY 5

int dx = 5;  // Delta X (px pro Frame)

int framedelay = 50;

int score = 0;
int lastScore = 0;
int fps = 0;
unsigned long lastFPSUpdate = 0;

const int jumpHeights[] = {
  -13, -10, -7, -5, -4, -3, -2,
   0,
   2, 3, 4, 5, 7, 10, 13
};
const int jumpLength = sizeof(jumpHeights) / sizeof(jumpHeights[0]); // Länge = ArrayLänge in Byte / Größe ArrayElement
bool jump = false;
int jumpProgress = 0;

int dead = 0;

void ButtonFunc(){
  //Serial.println("Hello from ButtonFunc");
  jump = true;
}

void setup() {
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), ButtonFunc, FALLING);

  Serial.begin(115200);
  
  // Initialisiere das TFT-Display
  tft.initR(INITR_BLACKTAB);
  tft.setRotation(1);
  tft.fillScreen(ST7735_WHITE);
  tft.setTextColor(ST7735_BLACK);

  reset();

}

void reset(){
  tft.fillScreen(ST7735_WHITE);
  tft.setCursor(55, 5);
  tft.print("DINO RUN!");
  score = 0;
  lastScore = 0;
  fps = 0;
  lastFPSUpdate = 0;

  jump = false;
  jumpProgress = 0;

  dead = 0;

  CloudX = tft.width() + random(-100, 70);
  CactusX = tft.width() + random(20, 100);
  DinoY = DinoYStart;
}

// https://kishimotostudios.com/articles/aabb_collision/
bool checkAABBCollision(int AX, int AY, int AWidth, int AHeight, int BX, int BY, int BWidth, int BHeight){
  int8_t padding = 4;

  int ALeft = AX + padding;
  int ARight = AX + AWidth - padding;
  int ATop = AY + padding;
  int ABottom = AY + AHeight - padding;

  int BLeft = BX;
  int BRight = BX + BWidth;
  int BTop = BY;
  int BBottom = BY + BHeight;

  bool AisToTheRightOfB = ALeft > BRight;
  bool AisToTheLeftOfB = ARight < BLeft;
  bool AisAboveB = ABottom < BTop;
  bool AisBelowB = ATop > BBottom;

  return !(AisToTheRightOfB
    || AisToTheLeftOfB
    || AisAboveB
    || AisBelowB);
}

void loop() {
  unsigned long now = millis();
  if (now - lastFPSUpdate >= 1000) {
    fps = score - lastScore;
    lastScore = score;
    lastFPSUpdate = now;
    // FPS anzeigen (z. B. seriell oder auf dem Bildschirm)
    tft.fillRect(tft.width() - 40, 5, 40, 10, ST7735_WHITE);
    tft.setCursor(tft.width() - 40, 5);
    tft.print(String("FPS:") + fps);
    Serial.println(String("FPS: ") + fps);
    Serial.println(String("lastFPSUpdate ") + lastFPSUpdate);
    Serial.println(String("lastScore ") + lastScore);
    Serial.println(String("now ") + now);
  }

  // Löschen
  tft.fillRect(CloudX, CloudY, CloudWidth, CloudHeight, ST7735_WHITE); // Wolke
  tft.fillRect(CactusX, CactusY, CactusWidth, CactusHeight, ST7735_WHITE); // Kaktus
  tft.fillRect(DinoX, DinoY, DinoWidth, DinoHeight, ST7735_WHITE); // Dino
  tft.fillRect(ScoreX, ScoreY, 30, 10, ST7735_WHITE); // Score

  // Neue Wolkenposition
  CloudX -= dx;
  if (CloudX <= -CloudWidth) {
    CloudX = tft.width() + random(10,70);
  }

  // Neue Kaktusposition
  CactusX -= dx;
  if (CactusX <= -CactusWidth) {
    CactusX = tft.width() + random(20,100);
  }

  if (jump == true) {
    DinoY += jumpHeights[jumpProgress];
    jumpProgress++;

    if (jumpProgress >= jumpLength) {
      jump = false;
      jumpProgress = 0;
    }
  }

  score++;
  tft.setCursor(ScoreX, ScoreY);
  tft.print(score);

  // collision
  if (checkAABBCollision(DinoX, DinoY, DinoWidth, DinoHeight, CactusX, CactusY, CactusWidth, CactusHeight)){
    Serial.println("Collison?");
    dead = 1;
  }

  tft.drawFastHLine(0, HLLineY, tft.width(), ST7735_BLACK); // horizontale Linie
  
  
  tft.drawBitmap(CloudX, CloudY, epd_bitmap_cloud, CloudWidth, CloudHeight, ST77XX_BLACK);
  tft.drawBitmap(CactusX, CactusY, epd_bitmap_cactus, CactusWidth, CactusHeight, ST77XX_BLACK);

  //tft.drawRect(CactusX, CactusY, CactusWidth, CactusHeight, ST77XX_RED);
  // Dino animieren
  if (dead != 1){
    if (DinoFrame == 0){
      //tft.drawRect(DinoX + 4, DinoY + 4, DinoWidth - 2 * 4, DinoHeight - 2 * 4, ST77XX_BLUE);

      tft.drawBitmap(DinoX, DinoY, epd_bitmap_dinohf, DinoWidth, DinoHeight, ST77XX_BLACK);
      delay(framedelay);
      DinoFrame = 1;
    }
    else if (DinoFrame == 1){
      //tft.drawRect(DinoX + 4, DinoY + 4, DinoWidth - 2 * 4, DinoHeight - 2 * 4, ST77XX_BLUE);
      tft.drawBitmap(DinoX, DinoY, epd_bitmap_dino2hf, DinoWidth, DinoHeight, ST77XX_BLACK);
      delay(framedelay);
      DinoFrame = 0;
    }
  }
  else { // tot
    //tft.drawRect(DinoX + 4, DinoY + 4, DinoWidth - 2 * 4, DinoHeight - 2 * 4, ST77XX_BLUE);
    tft.drawBitmap(DinoX, DinoY, epd_bitmap_deadhf, DinoWidth, DinoHeight, ST77XX_RED);
    delay(5000);
    reset();
  }
}

